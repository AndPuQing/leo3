//! Tests for the #[lean_instance] macro
//!
//! This macro generates FFI functions that implement Lean type classes for Rust types.

use leo3::external::LeanExternal;
use leo3::prelude::*;
use std::cmp::Ordering;

// Define a test struct with leanclass
#[derive(Clone, Debug)]
#[leanclass]
struct TestPoint {
    x: i32,
    y: i32,
}

// Implement BEq type class
#[leo3_macros::lean_instance(BEq)]
impl TestPoint {
    fn beq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

// Define another struct for Hashable
#[derive(Clone, Debug)]
#[leanclass]
struct HashablePoint {
    x: i32,
    y: i32,
}

// Implement Hashable type class
#[leo3_macros::lean_instance(Hashable)]
impl HashablePoint {
    fn hash(&self) -> u64 {
        // Simple hash combining x and y
        (self.x as u64).wrapping_mul(31).wrapping_add(self.y as u64)
    }
}

// Define struct for Repr
#[derive(Clone, Debug)]
#[leanclass]
struct ReprPoint {
    x: i32,
    y: i32,
}

// Implement Repr type class
#[leo3_macros::lean_instance(Repr)]
impl ReprPoint {
    fn repr(&self) -> String {
        format!("Point({}, {})", self.x, self.y)
    }
}

// Define struct for ToString
#[derive(Clone, Debug)]
#[leanclass]
struct StringPoint {
    x: i32,
    y: i32,
}

// Implement ToString type class
#[leo3_macros::lean_instance(ToString)]
impl StringPoint {
    fn to_string(&self) -> String {
        format!("({}, {})", self.x, self.y)
    }
}

// Define struct for Ord
#[derive(Clone, Debug)]
#[leanclass]
struct OrderedPoint {
    x: i32,
    y: i32,
}

// Implement Ord type class
#[leo3_macros::lean_instance(Ord)]
impl OrderedPoint {
    fn compare(&self, other: &Self) -> Ordering {
        // Compare by distance from origin (x^2 + y^2)
        let self_dist = self.x * self.x + self.y * self.y;
        let other_dist = other.x * other.x + other.y * other.y;
        self_dist.cmp(&other_dist)
    }
}

#[test]
fn test_beq_instance_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p1 = TestPoint { x: 1, y: 2 };
        let p2 = TestPoint { x: 1, y: 2 };
        let p3 = TestPoint { x: 3, y: 4 };

        // Test the beq method directly
        assert!(p1.beq(&p2));
        assert!(!p1.beq(&p3));

        // Create external objects
        let _ext1 = LeanExternal::new(lean, p1.clone()).unwrap();
        let _ext2 = LeanExternal::new(lean, p2).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}

#[test]
fn test_hashable_instance_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p = HashablePoint { x: 1, y: 2 };

        // Test hash method directly
        let h = p.hash();
        assert!(h > 0);

        // Consistent hashing
        assert_eq!(p.hash(), HashablePoint { x: 1, y: 2 }.hash());

        // Create external object
        let _ext = LeanExternal::new(lean, p).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}

#[test]
fn test_repr_instance_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p = ReprPoint { x: 3, y: 4 };

        // Test repr method directly
        assert_eq!(p.repr(), "Point(3, 4)");

        // Create external object
        let _ext = LeanExternal::new(lean, p).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}

#[test]
fn test_tostring_instance_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p = StringPoint { x: 5, y: 6 };

        // Test to_string method directly
        assert_eq!(p.to_string(), "(5, 6)");

        // Create external object
        let _ext = LeanExternal::new(lean, p).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}

#[test]
fn test_ord_instance_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p1 = OrderedPoint { x: 1, y: 1 }; // dist = 2
        let p2 = OrderedPoint { x: 2, y: 2 }; // dist = 8
        let p3 = OrderedPoint { x: 1, y: 1 }; // dist = 2

        // Test compare method directly
        assert_eq!(p1.compare(&p2), Ordering::Less);
        assert_eq!(p2.compare(&p1), Ordering::Greater);
        assert_eq!(p1.compare(&p3), Ordering::Equal);

        // Create external objects
        let _ext1 = LeanExternal::new(lean, p1).unwrap();
        let _ext2 = LeanExternal::new(lean, p2).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}

#[test]
fn test_ffi_functions_generated() {
    // This test verifies that the FFI functions exist and can be linked.
    // The actual calling of these functions happens from Lean.
    // We just verify the symbols exist.

    // These functions are generated by the #[lean_instance] macro:
    // - __lean_beq_TestPoint
    // - __lean_hash_HashablePoint
    // - __lean_repr_ReprPoint
    // - __lean_to_string_StringPoint
    // - __lean_compare_OrderedPoint

    // If this test compiles and links, the FFI functions exist.
}

// Test that multiple type classes can be implemented for the same type
#[derive(Clone, Debug)]
#[leanclass]
struct MultiTraitPoint {
    x: i32,
    y: i32,
}

#[leo3_macros::lean_instance(BEq)]
impl MultiTraitPoint {
    fn beq(&self, other: &Self) -> bool {
        self.x == other.x && self.y == other.y
    }
}

// Note: Can't have two impl blocks with the same methods for the same struct,
// so we create separate structs for each type class in the tests above.

#[test]
fn test_multi_trait_compiles() {
    leo3::prepare_freethreaded_lean();

    leo3::with_lean(|lean| {
        let p1 = MultiTraitPoint { x: 1, y: 2 };
        let p2 = MultiTraitPoint { x: 1, y: 2 };

        assert!(p1.beq(&p2));

        let _ext = LeanExternal::new(lean, p1).unwrap();

        Ok::<_, LeanError>(())
    })
    .unwrap();
}
